<center><img src="http://i.imgur.com/sSaOozN.png" width="500"></center>

## Course: Computational Thinking for Governance Analytics

### Prof. JosÃ© Manuel Magallanes, PhD 

_____

# Session 6:  Governance in Space in R


Let's work again with these data on contributions to Candidates and Political Committees in WAshington State. 

The WA [portal](https://data.wa.gov/) for OpenData has this data on this [website](https://data.wa.gov/Politics/Contributions-to-Candidates-and-Political-Committe/kv7h-kjye).

This portal has many of these data sets, and each has an **API** that allows you to get the data, or part of it via filters and SQL queries. The API for this data is [here](https://dev.socrata.com/foundry/data.wa.gov/74eq-kst5). 

Notice that the portal recommend getting an API for you to get the most of it. You can sign up [here](https://data.wa.gov/login).

To start getting the data, you need to use the **endpoint** for this data, which is **https://data.wa.gov/resource/74eq-kst5.json**. That link will give you access to the data, and you can add more filters and queries to it. Filters and queries can be combined using '**&**' (see that the token requires two of these '**$$**'). You can get more information on how to assemble filters and queries [here[(https://dev.socrata.com/docs/filtering.html). Please become familiar with APIs, these are a great way to access open data, when available.


## Getting Data of interest:

```{r, eval=TRUE}
#install.packages("jsonlite")
#this is my token, get yours:
token='&$$app_token=qkzOjPpAsJDHAxBVNro7U82j5'

#this is the endpoint:
endpoint="https://data.wa.gov/resource/74eq-kst5.json?"

#subsetting at API:
filters='&jurisdiction_type=Statewide'
sqlQueries='&$where=election_year >= 2012'
limit='$limit=4000000'

#building url:
urlLink = paste0(endpoint,limit,filters,token)
```
```{r, echo=F}
#urlLink = "https://data.wa.gov/resource/74eq-kst5.json?jurisdiction_type=Statewide&$where=election_year>=2012&$limit=4000000&$$app_token=qkzOjPpAsJDHAxBVNro7U82j5" 

```


```{r, eval=TRUE}
library(jsonlite) 
contributions = fromJSON(urlLink)
```

WHAT do we have?
```{r, eval=TRUE}
is.data.frame(contributions)
```

What variables are present?

```{r, eval=TRUE}
names(contributions)
```

I do not need that many columns, let me keep some small set of columns:

```{r, eval=TRUE}
contributions=contributions[,c('contributor_state','contributor_zip','amount','election_year','party')]
```

Checking data types:
```{r, eval=TRUE}
str(contributions)
```

I am planing to show you how to plot the contributions per ZIP code in WA. The amount column has that information, but it is a character, not a number:
```{r, eval=TRUE}
contributions$amount=as.numeric(contributions$amount)
```

We could get rid of the contributors that are not from WA. Let's see the contributor_state column:

```{r, eval=TRUE}
table(contributions$contributor_state)
```

As there are more States involved, we will keep just WA, and subset:

```{r, eval=TRUE}
WASzip=contributions[contributions$contributor_state%in%'WA',]
```


This has diminished the file. Let's reset the index of the current data frame:

```{r, eval=TRUE}
row.names(WASzip)=NULL # good practice
```


We want to make a map of zip codes of WA. Then we just need to verify that we have correct zip values. If we go to this [link](https://www.unitedstateszipcodes.org/wa/), we realize that they are between some values: 98001 and 99403. 

Remember we can use the comparison operands with text, but it is not doing arithmetical comparissons:
```{r, eval=TRUE}
'985'>'9800'
```

And our zip values look:

```{r, eval=TRUE}
WASzip$contributor_zip[1] #the first value
```

Then, in cases like these, we simply turn the column as numeric. The text values representing numbers will become numbers, if it is not a number, they will turn into a NA.

```{r, eval=TRUE}
WASzip$contributor_zip=as.numeric(WASzip$contributor_zip)
```


As the cells have integers, I am confident to use comparisons:
```{r, eval=TRUE}
WASzip=WASzip[(WASzip$contributor_zip <=99403) & (WASzip$contributor_zip>=98001),]
```

Remember that there may be missing values somewhere else, just get rid of them:
```{r, eval=TRUE}
WASzip=WASzip[complete.cases(WASzip),]
```


I will reset indexes again after the _complete.cases_ we applied before:

```{r, eval=TRUE}
row.names(WASzip)=NULL # good practice
```


The last step is to create a new data frame from this one. In the current one, each row represented a contribution; we do not need that, we need a data frame where each row is ZIP code, and the amount tells us the total contribution generated in that location. This is an **aggregation** process:

```{r, eval=TRUE}
# similar and saving space:
numericColumns =c("amount")
aggregateBY='contributor_zip'

WA_zip_contri=aggregate(WASzip[,numericColumns], by=list(WASzip[,aggregateBY]), sum )
names(WA_zip_contri)=c('contributor_zip','amount')
```

```{r, eval=TRUE}
#see result:
head(WA_zip_contri)
```


This information should be sent to a map.



## Getting the Map

Maps come in different formats. The most common is the **shapefile** which is in fact a collection of files. That makes it more complicated if we save the map in GitHub. To keep using GitHub to store maps, you should create a folder and compress it (zip it). That zip file is the one you need in GitHub.
```{r, eval=TRUE}
compressedMap= "https://github.com/EvansDataScience/data/raw/master/WAzips.zip"

```

The strategy in R will be to download the compressed file into your computer. Then, everything will be decompressed. The files will be avilable in the  directory where you are writing the R project.

```{r, eval=TRUE}
library(utils)
temp=tempfile()
download.file(compressedMap, temp)
unzip(temp)
```

To know what shapefiles are now in your directory:
```{r, eval=TRUE}
(maps=list.files(pattern = 'shp'))
```

You select which map from the object _maps_ you need:
```{r, eval=TRUE}
library(rgdal)
wazipMap <- rgdal::readOGR("SAEP_ZIP_Code_Tabulation_Areas.shp",stringsAsFactors=F) # use name
```

Now that you have a map, you can use common commands and see what you have:
```{r, eval=TRUE}
names(wazipMap)
```

The column with the zip code has the name ZCTA5CE10, let's check its data type:
```{r, eval=TRUE}
str(wazipMap$ZCTA5CE10)
```


In our previous data (WA_zip_contri) with amount aggregated by zip code, we had integers:

```{r, eval=TRUE}
str(WA_zip_contri$contributor_zip)
```

Let's turn _ZCTA5CE10_ to integer:

```{r, eval=TRUE}
wazipMap$ZCTA5CE10=as.numeric(wazipMap$ZCTA5CE10)
```


As both are of the same type, we can merge. 

As the zip codes in each are under different name columns, I tell the _merge_ function what columns to use:

```{r, eval=TRUE}
contribWAmap=merge(wazipMap,WA_zip_contri, by.x='ZCTA5CE10', by.y='contributor_zip',all.x=F)
```

The new map _contribWAmap_ may have less rows:
```{r, eval=TRUE}
nrow(contribWAmap)
```

Than the original one:
```{r, eval=TRUE}
nrow(wazipMap)
```

So, our last map does not have information on contributions for 11 zip codes. Let me plot the original map in black, and the new one in pink, to have an idea where I did not get a contribution:

```{r, eval=TRUE}
plot(wazipMap,col='black')
plot(contribWAmap,col='pink',border='grey',add=T)
```


All that we have done so far was not to produce that map, but to show in the map the information about contributions (_amount_). We have amounts, but we should not use that directly. We should compute a ratio, like:

$\frac{contributionOfZIP}{PopulationOfZIP}$

We do not have the zip area, but we do have a column on population:



```{r, eval=TRUE}
#NOW that you are in maps, make sure column names are not longer than 10 characters
contribWAmap$contribDen=contribWAmap$amount/contribWAmap$POP2017
```

The variable to plot is apparently ready, but let's explore it:
```{r, eval=TRUE}
summary(contribWAmap$contribDen)
```

We got an inf, because some zip codea had no population:
```{r, eval=TRUE}
# notice the use of '@data'
#finding the issue:
contribWAmap@data[contribWAmap$contribDen==Inf,]['contribDen']
```

We need to get rid of those rows:
```{r, eval=TRUE}
contribWAmap=contribWAmap[contribWAmap$contribDen!=Inf,]
```

That has solved the problem:

```{r, eval=TRUE}
summary(contribWAmap$contribDen)
```


We will plot the new variable asking for 5 quantiles. Let's follow these steps:

1. Install and load the necessary packages to manage color and divisions:

```{r, eval=TRUE}
library(RColorBrewer)
library(classInt)
```


2. Define the input:
```{r, eval=TRUE}
varToPLot=contribWAmap$contribDen
```


3. Get colors and intervals (you can choose palettes from [here](http://colorbrewer2.org/)):

```{r, eval=TRUE}
numberOfClasses = 5
colorForScale='YlGnBu'
colors = brewer.pal(numberOfClasses, colorForScale)
intervals <- classIntervals(varToPLot, numberOfClasses, 
                            style = "quantile",
                            dataPrecision=2)
colorPallette <- findColours(intervals, colors)
```

4. Plot
```{r, eval=TRUE}

legendText="contribution rate"
shrinkLegend=0.4
title="Contribution towards candidates in WA since 2012"

plot(wazipMap,col='red',main=title)
plot(contribWAmap, col = colorPallette,border='grey',add=T)

legend('topright', legend = names(attr(colorPallette, "table")), 
       fill = attr(colorPallette, "palette"), cex = shrinkLegend, 
       bty = "n",
       title=legendText)
```


### What if we had categories?

The situation is pretty similar. First get the data:

```{r, eval=TRUE}
library(XML)
library(RCurl)

# URL
wikiLink="https://en.wikipedia.org/wiki/Democracy_Index" 

# Data
wikiLinkContents = getURL(wikiLink) 
wikiTables = readHTMLTable(wikiLinkContents,stringsAsFactors=FALSE)
demodex=wikiTables[[5]]
names(demodex)
```


Convert _Category_ to the right type:
```{r, eval=TRUE}
levelCat=c("Authoritarian","Hybrid regime","Flawed democracy","Full democracy")

# Formatting:
demodex$Category=factor(demodex$Category,
                        levels = levelCat,
                        labels=levelCat,ordered=T)
```

Get rid of rows with missing values:
```{r, eval=TRUE}
demodex=demodex[complete.cases(demodex),]
```

Get the map from Github:

```{r, eval=TRUE}
compressedMap2='https://github.com/EvansDataScience/data/raw/master/worldMap.zip'

temp=tempfile()
download.file(compressedMap2, temp)
unzip(temp)
```

See the shapefiles you have:
```{r, eval=TRUE}
(maps=list.files(pattern = 'shp'))
```

You select which map you need:
```{r, eval=TRUE}
library(rgdal)
worldMap <- rgdal::readOGR('worldMap.shp',stringsAsFactors=F) # use the names
```

```{r, eval=TRUE}
names(worldMap)
```

**Demodex** has no ISO nor FIPS code. Now, we could only use Name and Country to do the merge (we may lose several countries). 

Let's do the merging:

```{r, eval=TRUE}
worldMapDem=merge(worldMap,demodex, by.x='NAME', by.y='Country',all.x=F)
```

Plotting both maps to see missing countries in the last one:

```{r, eval=TRUE}
plot(worldMap,col='black')
plot(worldMapDem,col='pink',border='grey',add=T)

```

Now prepare to plot the categorical column:

1. Install and load the necessary packages to manage color and divisions:

```{r, eval=TRUE}
library(RColorBrewer)
library(classInt)
```


2. Define the input:
```{r, eval=TRUE}
varToPLot=worldMapDem$Category
```


3. Get colors and intervals:

```{r, eval=TRUE}
numberOfClasses = length(levels(varToPLot)) # first change
colorForScale='Set2'
colors = brewer.pal(numberOfClasses, colorForScale)
```


4. Plot
```{r, eval=TRUE}

legendText="Democracy Level"
shrinkLegend=0.4
title="How democracy is spread around the world (2016)"

plot(worldMap,col='black',main=title)
# second change: col = colors[varToPLot]
plot(worldMapDem, col = colors[varToPLot],border='grey',add=T)

legend('left', legend = levels(varToPLot), # third change
       fill = colors, # fourth change
       cex = shrinkLegend, 
       bty = "n",
       title=legendText)
```


____

* [Go to Course schedule](https://evansdatascience.github.io/GovernanceAnalytics/)
